一 连通块

1输入图的规模 和 图
2随便找到""一个连通块的点,执行深搜,向周围的给定方向去搜
3执行的第一次会把第一个点周围所有可遍及的地方都走遍,并且在走的时候把当前的点改变状态,让他不能再走
4我们记录这个循环判断后的执行次数就总的连通块的数量

dfs(){
	当前位置改变为不可走的状态;
	枚举周围给定方向,
		在图内且符合可走的条件
		执行深搜


	return ;
}
_______________________________________________________________________


二找出口

1从起点开始,获取起点坐标,dfs(x,y)
2dfs(x,y)
	a.判断是否终点
		标记为真,返回
	b.图范围之外,不可行(有障碍),已走过
		return;
	c.枚举四个方向dfs(nx,ny);
3判断之前的标记是否为真,及是否到达那一步
	if(f)
		yes;
	else
		no;


______________________________________________________________________
三最短路

dfs(int x,int y,int step){
	if(到达目标位置){
		更新最路径长度
	}

	for(int i=0;i<4;i++){
		循环四个方向去搜索
		if(循环后位置可行 && 没有被访问过)
			vis[][]=1//设置已经访问	
			dfs(tx,ty,step+1)//递归调用
			vis[tx][ty]=0//方便让他回溯
	}
	
	return ;	
}

main(){
	cin>>规模
	循环输入
		cin>>图
	输入起点终点

	将起点设置已经访问
	dfs(起x,起y,step=0);
	

	cout<<最小路径
}

	
