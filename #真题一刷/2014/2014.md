# 2014

## 武功秘籍

>小明到X山洞探险，捡到一本有破损的武功秘籍（2000多页！当然是伪造的）。
>他注意到：书的第10页和第11页在同一张纸上，但第11页和第12页不在同一张纸上 。
>小明只想练习该书的第a页到第b页的武功，又不想带着整本书。请问他至少要撕下多少张纸带走？

```c
9|10-11|12
求81-92

80|*81*
82|83
84|85
86|87
88|89
90|91
*92*|93

七张
```



## 等额本金

> 小明从银行贷款3万元。约定分24个月，以等额本金方式还款。
> 这种还款方式就是把贷款额度等分到24个月。
> 每个月除了要还固定的本金外，还要还贷款余额在一个月中产生的利息。
> 假设月利率是：0.005，即：千分之五。那么，
> 第一个月，小明要还本金 1250, 还要还利息：30000 * 0.005，总计 1400
> 第二个月，本金仍然要还 1250, 但利息为：(30000-1250) * 0.005 总计 1393.75
> 请问：小明在第15个月，应该还款多少（本金和利息的总和）？
> 请把答案金额四舍五入后，保留两位小数。注意：32.5，一定要写为：**32.50**
> 通过浏览器提交答案，这是一个含有小数点和两位小数的浮点数字。

```c
#include <stdio.h>
int main(){
	float benjin=30000.00;
	for(int i=1;i<=15;i++){
		float ans=1250+benjin*0.005;
		benjin-=1250;
		printf("%.2f\n",ans);
	}
	//1312.50注意这里有个坑要填写答案1312.50（题目要求） 
	return 0;
}
```





## 大衍数列

> 中国古代文献中，曾记载过“大衍数列”, 主要用于解释中国传统文化中的太极衍生原理。
> 它的前几项是：0、2、4、8、12、18、24、32、40、50 ...
> 其规律是：对**偶数项，是序号平方再除2**;;**奇数项，是序号平方减1再除2**。
> 以下的代码打印出了大衍数列的前 100 项。

```c
#include <stdio.h>
int main(int argc, char *argv[])
{
	for(int i=1;i<=100;i++){
		if(i%2==0){//偶数的条件 
			printf("%d ",i*i/2);
		}
		else
			printf("%d ",(i*i-1)/2); 
	}
    
	return 0;
}
```

这是一道代码填空题，填空位置是注释前括号内的条件；

也就是判断i为偶数的条件



## 地宫取宝

>X 国王有一个地宫宝库。是 n x m 个格子的矩阵。每个格子放一件宝贝。每个宝贝贴着价值标签。
>
>地宫的入口在左上角，出口在右下角。
>
>小明被带到地宫的入口，国王要求他只能向右或向下行走。
>
>走过某个格子时，如果那个格子中的宝贝价值比小明手中任意宝贝价值都大，小明就可以拿起它（当然，也可以不拿）。
>
>当小明走到出口时，如果他手中的宝贝恰好是k件，则这些宝贝就可以送给小明。
>
>请你帮小明算一算，在给定的局面下，他有多少种不同的行动方案能获得这k件宝贝。
>输入格式
>　　输入一行3个整数，用空格分开：n m k (1<=n,m<=50, 1<=k<=12)
>
>接下来有 n 行数据，每行有 m 个整数 Ci (0<=Ci<=12)代表这个格子上的宝物的价值
>输出格式
>　　要求输出一个整数，表示正好取k个宝贝的行动方案数。该数字可能很大，输出它对 1000000007 取模的结果。
>样例输入
>2 2 2
>1 2
>2 1
>样例输出
>2
>样例输入
>2 3 2
>1 2 3
>2 1 5
>样例输出
>14

```c
#include <stdio.h>
int n,m,k;
int data[50][50];
long long ans;
void dfs(int x,int y,int max,int cnt){
	if(x==n||y==m)
		return;
			
	int cur=data[x][y];
	if(x==n-1&&y==m-1){
		if( cnt==k || (cnt==k-1&&cur>max) ){
			ans++;
			if(ans>1000000007)
				ans%=1000000007;
		}
		
	}
	if(cur>max){
		dfs(x,y+1,cur,cnt+1);
		dfs(x+1,y,cur,cnt+1);		
	}
	dfs(x,y+1,max,cnt);
	dfs(x+1,y,max,cnt);
}
int main(int argc, char *argv[])
{
	scanf("%d %d %d",&n,&m,&k);
	for(int i=0;i<n;i++){
		for(int j=0;j<m;j++){
			scanf("%d",&data[i][j]);	
		}	
	}
	dfs(0,0,-1,0);
	printf("%d\n",ans);		
	return 0;
}
//60分样例；优化的话试下记忆化数组将递归结果保存下来

```



