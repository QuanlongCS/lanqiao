# 2013



## 猜年龄 
美国数学家维纳（N.Wiener）智力早熟，11岁就上了大学。他曾在1935~1936年应邀来中国清华大学讲学。一次，他参加某个重要会议，**年轻**的脸孔引人注目。于是有人询问他的年龄，他回答说：“**我年龄的立方是一个4位数**。**我年龄的4次方是一个6位数**。这**10个数字正好包含了从0到9这10个数字，每个都恰好出现1次**。”请你编程算出他当时到底有多年轻。
简单枚举，10-30岁，判断出i1=i * i * i，i2=i1*i，限制条件内且不重复。将结果输出肉眼观察

```c
#include <iostream>
using namespace std;
int main(int argc, char *argv[])
{	
	int a,b;
	for(int i=10;i<=30;i++){
		a=i*i*i;
		b=a*i;
		if(a>999&&a<=9999&&b>100000&&b<999999)
			cout<<i<<" "<<a<<" "<<b<<endl; 
	}
	return 0;
}
//18
```
————————————————————————————
## 马虎算式
小明是个急性子，上小学的时候经常把老师写在黑板上的题目抄错了。
    有一次，老师出的题目是：36 x 495 = ?
    他却给抄成了：396 x 45 = ?
    但结果却很戏剧性，他的答案竟然是对的！！
    因为 36 * 495 = 396 * 45 = 17820
    类似这样的巧合情况可能还有很多，比如：27 * 594 = 297 * 54
    假设 **a b c d e 代表1~9不同的5个数字**（注意是各不相同的数字，**且不含0**）
    能满足形如： **ab * cde = adb * ce** 这样的算式一共有多少种呢？
请你利用计算机的优势寻找所有的可能，并回答不同算式的种类数。
满足乘法交换律的算式计为不同的种类，所以答案肯定是个**偶数**。

```c
#include <stdio.h>
int main(int argc, char *argv[])
{int cnt=0;
	for(int a=1;a<10;a++){
		for(int b=1;b<10;b++){
		if(a!=b){
			for(int c=1;c<10;c++){
			if(c!=a&&c!=b){
				for(int d=1;d<10;d++){
				if(d!=a&&d!=b&&d!=c)
					for(int e=1;e<10;e++){
						if(e!=a&&e!=b&&e!=c&&e!=d)
						if((a*10+b)*(c*100+d*10+e)==(a*100+d*10+b)*(c*10+e) )
							cnt++;
					}
				}
			}
				
			}	
			}
		}
	}
	printf("%d",cnt);
	return 0;
}//142
//代码有点乱大概就是abcde一个个枚举1~9，同时abcde之间互异再判断一下ab * cde = adb * ce，count++;输出
```
————————————————————————————
## 振兴中华
小明参加了学校的趣味运动会，其中的一个项目是：跳格子。
    地上画着一些格子，每个格子里写一个字，如下所示：
	**从我做起振
	我做起振兴
	做起振兴中
	起振兴中华**
    比赛时，先站在左上角的写着“**从**”字的格子里，可以**横向或纵向跳到相邻**的格子里，**但不能跳到对角**的格子或其它位置。**一直要跳到“华”字结束**。
    要求跳过的路线刚好构成“从我做起振兴中华”这句话。请你帮助小明算一算他一**共有多少种可能的跳跃路线呢？**
```c
#include <stdio.h>

//0 1 2 3 4
//1 
//2
//3 
int f(int x,int y){
	if(x == 3 || y ==4)//按照边边走 
		return 1;
	return f(x+1,y)+f(x,y+1);//右下 
	
}
int main(int argc, char *argv[])
{
	printf("%d",f(0,0))	;
	return 0;
}

//35，起点是0，0;靠着边走是2条就是x==3，y==4；
//两种方向右下（x+1，y） （x，y+1）
```


————————————————————————————

## 最大公约数，最小公倍数

这道题是一个代码填空题比较简单，去年蓝桥杯好像删了代码填空所以就当复习一下gcd lcm；

```cpp
#include <stdio.h>
//最大公约数，最小公倍数 
//x*y/gcd(x,y)
int gcd(int a,int b){//求gcd1
	int t;
	while(t){
		t=a%b;
		a=b;//8%4//(a=b)==4
		b=t;
/*
int GCD(int num1,int num2)
{
	if(num1%num2==0)
		return num2;
	else return  GCD(num2,num1%num2);
}
*/		
	}
return a;
}

int main(){
printf("gcd=%d\n",gcd(8,12));

printf("lcm=%d",12*8/gcd(12,8));
	return 0;
}
/*有两种求gcd的方法一个是递归一个是循环，本质都是辗转相除法递归更简单一点好像，容易理解。
if(a%b==0)
		return b;//举个栗子8%4=0
	else return  GCD(num2,num1%num2);//12,8
}
lcm是a*b/gcd（a,b）
*/
```

—————————————————————————
## 核桃数量

小张是软件项目经理，他带领3个开发组。工期紧，今天都在加班呢。为鼓舞士气，小张打算给每个组发一袋核桃（据传言能补脑）。他的要求是：

1. 各组的核桃数量必须相同

2. 各组内必须能平分核桃（当然是不能打碎的）

3. 尽量提供满足1,2条件的最小数量（节约闹革命嘛）

输入格式
输入包含三个正整数a, b, c，表示每个组正在加班的人数，用空格分开（a,b,c<30）
输出格式
输出一个正整数，表示每袋核桃的数量。
样例输入1
2 4 5
样例输出1
20
样例输入2
3 1 1
样例输出2
3

```c
#include <stdio.h>
int main(){
//核桃数量 样例2 4 5==20;	3 1 1==3；	
//a b c最小公倍数 
	int a,b,c;
	scanf("%d %d %d",&a,&b,&c); 
	int cnt=a*b*c;
	for(int i=1;i<=cnt;i++){
		if(i%a==0&&i%b==0&&i%c==0){
			printf("%d ",i);
			break;	
		}	
	} 
		
	return 0;
}
```

> 就这么多吧其他题目有些难度了，2013年题枚举还是很多的。
> 2020/3/28完