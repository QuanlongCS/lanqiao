## 试题 A: 求和

> 本题总分： 5 分

> 【问题描述】
> 小明对数位中含有 2、 0、 1、 9 的数字很感兴趣，在 1 到 40 中这样的数包
> 括 1、 2、 9、 10 至 32、 39 和 40，共 28 个，他们的和是 574。
> 请问，在 1 到 2019 中，所有这样的数的和是多少？
> 【答案提交】
> 这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一
> 个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。  

```c
#include <stdio.h>
int check(int n){
	while(n){
		if(n%10==0||n%10==2||n%10==1||n%10==9){//314%10=4取最后一位
			return 1;
		}

		n/=10;//循环递增条件；314/10=31
	}
	return 0;
}
int main(int argc, char *argv[])
{
	int sum=0;
	for(int i=1;i<=2019;i++){
		if(check(i)){
			
			sum+=i;
		}
		
	}
	printf("%d",sum);
	return 0;
}
//1905111请按任意键继续. . .
//先过样例1~40枚举是否包含2019累加
//再改成2019
```

## 试题 B: 矩形切割

> 本题总分： 5 分
>
> 【问题描述】
> 小明有一些矩形的材料，他要从这些矩形材料中切割出一些正方形。
> 当他面对一块矩形材料时，他总是从中间切割一刀，切出一块最大的正方
> 形，剩下一块矩形，然后再切割剩下的矩形材料，直到全部切为正方形为止。
>
> 例如，对于一块两边分别为 5 和 3 的材料（记为 5 × 3），小明会依次切出
> 3 × 3、 2 × 2、 1 × 1、 1 × 1 共 4 个正方形。
> 现在小明有一块矩形的材料，两边长分别是 2019 和 324。请问小明最终会
> 切出多少个正方形？
> 【答案提交】
> 这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一
> 个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。  

```c
解法1
    //每次边都是较小的那条边;	5:3;	5/3=1...2
    2019/324=6...75
    324/75=4...24
    75/24=3...3
    24/3=8
    6+4+3+8=21;
解法2
    #include <stdio.h>
int max,min,cnt;
void f(int x,int y){
	cnt++;
	max=x>y?x:y;
	min=x<y?x:y;
	printf("%d %d\n",max,min);
	
	if(max<=1&&min<=1||max==min)
		return ;
	
	f(min,max-min);
		
}
int main(int argc, char *argv[])
{
	f(2019,324);
	printf("ans=%d\n",cnt);
	return 0;
}//代码很直观不过多解释
```

## 试题 C: 年号字串

> 本题总分： 10 分
> 【问题描述】
> 小明用字母 A 对应数字 1， B 对应 2，以此类推，用 Z 对应 26。对于 27
> 以上的数字，小明用两位或更长位的字符串来对应，例如 AA 对应 27， AB 对
> 应 28， AZ 对应 52， LQ 对应 329。
> 请问 2019 对应的字符串是什么？
> 【答案提交】
> 这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一
> 个大写英文字符串，在提交答案时只填写这个字符串，注意全部大写，填写多
> 余的内容将无法得分  

```c
BYQ
    用excel横着拉
```

## 试题 D: 质数

> 本题总分： 10 分
> 【问题描述】
> 我们知道第一个质数是 2、第二个质数是 3、第三个质数是 5……请你计算
> 第 2019 个质数是多少？
> 【答案提交】
> 这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一
> 个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。  

```c
//2019:   17569
#include<stdio.h>

int check(int n){
	for(int j=2;j<n;j++){
		if(n%j==0)
		return 0;			
			
	}	
	return 1;
}
int main()
{
    
  	int x=1;
    for(int i = 2; i <= 9999*2 ; i++){
		if(check(i))	
			printf("%d:	%d\n",x++,i);
			
	}
    return 0;
 
}

```

## 试题 E: 最大降雨量

> 本题总分： 15 分
> 【问题描述】
> 由于沙之国长年干旱，法师小明准备施展自己的一个神秘法术来求雨。
> 这个法术需要用到他手中的 49 张法术符，上面分别写着 1 至 49 这 49 个
> 数字。法术一共持续 7 周，每天小明都要使用一张法术符，法术符不能重复使
> 用。
> 每周，小明施展法术产生的能量为这周 7 张法术符上数字的中位数。法术
> 施展完 7 周后，求雨将获得成功，降雨量为 7 周能量的中位数。
> 由于干旱太久，小明希望这次求雨的降雨量尽可能大，请大最大值是多少？
> 【答案提交】
> 这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一
> 个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。  

```c
1  2  3		49 48 47 	46
4  5  6		45 44 43 	42
7  8  9		41 40 39 	38
10 11 12	37 36 35 // 34 
13 14 15 	33 32 31 	30
16 17 18	29 28 27 	26
19 20 21	25 24 23 	22
    需要注意的是要求
    	小明希望这次求雨的降雨量尽可能大。
    让这个中位数尽可能的大
```



## 试题 F: 旋转

> 时间限制: 1.0s 内存限制: 256.0MB 本题总分： 15 分
> 【问题描述】
> 图片旋转是对图片最简单的处理方式之一，在本题中，你需要对图片顺时
> 针旋转 90 度。
> 我们用一个 n × m 的二维数组来表示一个图片，例如下面给出一个 3 × 4 的
> 图片的例子：
> 1 3 5 7
> 9 8 7 6
> 3 5 9 7
> 这个图片顺时针旋转 90 度后的图片如下：
> 3 9 1
> 5 8 3
> 9 7 5
> 7 6 7
> 给定初始图片，请计算旋转后的图片。
> 【输入格式】
> 输入的第一行包含两个整数 n 和 m，分别表示行数和列数。
> 接下来 n 行，每行 m 个整数，表示给定的图片。图片中的每个元素（像
> 素）为一个值为 0 至 255 之间的整数（包含 0 和 255）。
> 【输出格式】
> 输出 m 行 n 列，表示旋转后的图片。
> 试题F: 旋转 7
> 第十届蓝桥杯大赛软件类省赛 C/C++ 大学 C 组
> 【样例输入】
> 3 4
> 1 3 5 7
> 9 8 7 6
> 3 5 9 7
> 【样例输出】
> 3 9 1
> 5 8 3
> 9 7 5
> 7 6 7
> 【评测用例规模与约定】
> 对于 30% 的评测用例， 1 ≤ n; m ≤ 10。
> 对于 60% 的评测用例， 1 ≤ n; m ≤ 30。
> 对于所有评测用例， 1 ≤ n; m ≤ 100。  

```c
#include <stdio.h>
int n,m;
int arr[105][105];
int main(int argc, char *argv[])
{
	scanf("%d%d",&n,&m);
	for(int i=0;i<n;i++){
		for(int j=0;j<m;j++){
			scanf("%d",&arr[i][j]);
		}
	}
	
	for(int i=0;i<m;i++){
		for(int j=0;j<n;j++){

			printf("%d ",arr[n-j-1][i]);
		}
		printf("\n");
	}
	
	
	return 0;
}
/*
3 4
1 3 5 7
9 8 7 6
3 5 9 7
*/
```

## 试题 I: 等差数列

> 时间限制: 1.0s 内存限制: 256.0MB 本题总分： 25 分
> 【问题描述】
> 数学老师给小明出了一道等差数列求和的题目。但是粗心的小明忘记了一
> 部分的数列，只记得其中 N 个整数。
> 现在给出这 N 个整数，小明想知道包含这 N 个整数的最短的等差数列有
> 几项？
> 【输入格式】
> 输入的第一行包含一个整数 N。
> 第二行包含 N 个整数 A1; A2; · · · ; AN。 (注意 A1 ∼ AN 并不一定是按等差数
> 列中的顺序给出)
> 【输出格式】
> 输出一个整数表示答案。
> 【样例输入】
> 5
> 2 6 4 10 20
> 【样例输出】
> 10
> 【样例说明】
> 包含 2、 6、 4、 10、 20 的最短的等差数列是 2、 4、 6、 8、 10、 12、 14、 16、
> 18、 20。
> 试题 I: 等差数列 13
>
> 【评测用例规模与约定】
> 对于所有评测用例， 2 ≤ N ≤ 100000， 0 ≤ Ai ≤ 109。  

```c++
#include <cstdio>
#include <algorithm>
using namespace std;
int N;
int A[99999999];

int main(int argc, char *argv[])
{
	int start,end;
	int ans=1; 
	scanf("%d",&N);
	for(int i=0;i<N;i++){
		scanf("%d",&A[i]);
	}
	
	sort(A,A+N);
	
	int X=A[1]-A[0];
	int Y=A[N-1]-A[N-2]; 
	int condif=X<Y?X:Y;
	start=A[0];
	end=A[N-1];
	

		while(start<end){
 		ans++;
		start+=condif; 
		 
		}
		printf("%d ",ans);	
	
	
	return 0;
}

//乍一看很简单，给数组排下序，找下公差，让数组头+公差加到数组尾部，累计一下。
//但是，我只能给出这两种情况的公差，int X=A[1]-A[0];int Y=A[N-1]-A[N-2]; 
//学艺不精
```

