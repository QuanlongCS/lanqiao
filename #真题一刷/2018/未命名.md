## 哪天返回

>小明被不明势力劫持。后被扔到x星站再无问津。小明得知每天都有飞船飞往地球，但需要108元的船票，而他却身无分文。
>他决定在x星战打工。好心的老板答应包食宿，第1天给他1元钱。
>并且，以后的每一天都比前一天多2元钱，直到他有足够的钱买票。
>请计算一下，小明在第几天就能凑够108元，返回地球。

```c
#include <stdio.h>
int main(int argc, char *argv[])
{	int total=1;
	int day=1;
	int money=1;
	printf("day:%d,money:%d,total:%d\n",day,money,total);
	while(total<108){
		day++;
		money+=2;
		total+=money;
		printf("day:%d,money:%d,total:%d\n",day,money,total);
	}
	printf("%d\n",day);
	return 0;
}
11
```

设置第一天初始化工资1，总钱数1。

每一天都比前一天多2元钱；即13579...;累加器加起来；

第11天就能凑大于108元

## 猴子分香蕉

>5只猴子是好朋友，在海边的椰子树上睡着了。这期间，有商船把一大堆香蕉忘记在沙滩上离去。
>第1只猴子醒来，把香蕉均分成5堆，还剩下1个，就吃掉并把自己的一份藏起来继续睡觉。
>第2只猴子醒来，重新把香蕉均分成5堆，还剩下2个，就吃掉并把自己的一份藏起来继续睡觉。
>第3只猴子醒来，重新把香蕉均分成5堆，还剩下3个，就吃掉并把自己的一份藏起来继续睡觉。
>第4只猴子醒来，重新把香蕉均分成5堆，还剩下4个，就吃掉并把自己的一份藏起来继续睡觉。
>第5只猴子醒来，重新把香蕉均分成5堆，哈哈，正好不剩！
>
>请计算一开始最少有多少个香蕉。

```c
#include <stdio.h>
int main(int argc, char *argv[])
{//5^5=3125
	for(int i=3125;i<=100000;i++){
		if(i%5==1){
			int a=i;
			int b=((a-1)/5)*4;
			if(b%5==2){
				int c=((b-2)/5)*4;
				if(c%5==3){
					int d=((c-1)/5)*4;
					if(d%5==4){
						int e=((d-1)/5)*4;
						if(e%5==0){
							printf("%d\n",i);	
							break;
							}
					}
				}
			}
			
		}
		
		
	}
	return 0;
}
//枚举暴力get
```

## 明码

>汉字的字形存在于字库中，即便在今天，16点阵的字库也仍然使用广泛。

> 16点阵的字库把每个汉字看成是16x16个像素信息。并把这些信息记录在字节中。

> 一个字节可以存储8位信息，用32个字节就可以存一个汉字的字形了。
> 把每个字节转为2进制表示，1表示墨迹，0表示底色。每行2个字节，
>
> 一共16行，布局是：
>   第1字节，第2字节
>   第3字节，第4字节
>   ....
>   第31字节, 第32字节

> 这道题目是给你一段多个汉字组成的信息，每个汉字用32个字节表示，这里给出了字节作为有符号整数的值。

> 题目的要求隐藏在这些信息中。你的任务是复原这些汉字的字形，从中看出题目的要求，并根据要求填写答案。

> 这段信息是（一共10个汉字）：
> 4 0 4 0 4 0 4 32 -1 -16 4 32 4 32 4 32 4 32 4 32 8 32 8 32 16 34 16 34 32 30 -64 0 
> 16 64 16 64 34 68 127 126 66 -124 67 4 66 4 66 -124 126 100 66 36 66 4 66 4 66 4 126 4 66 40 0 16 
> 4 0 4 0 4 0 4 32 -1 -16 4 32 4 32 4 32 4 32 4 32 8 32 8 32 16 34 16 34 32 30 -64 0 
> 0 -128 64 -128 48 -128 17 8 1 -4 2 8 8 80 16 64 32 64 -32 64 32 -96 32 -96 33 16 34 8 36 14 40 4 
> 4 0 3 0 1 0 0 4 -1 -2 4 0 4 16 7 -8 4 16 4 16 4 16 8 16 8 16 16 16 32 -96 64 64 
> 16 64 20 72 62 -4 73 32 5 16 1 0 63 -8 1 0 -1 -2 0 64 0 80 63 -8 8 64 4 64 1 64 0 -128 
> 0 16 63 -8 1 0 1 0 1 0 1 4 -1 -2 1 0 1 0 1 0 1 0 1 0 1 0 1 0 5 0 2 0 
> 2 0 2 0 7 -16 8 32 24 64 37 -128 2 -128 12 -128 113 -4 2 8 12 16 18 32 33 -64 1 0 14 0 112 0 
> 1 0 1 0 1 0 9 32 9 16 17 12 17 4 33 16 65 16 1 32 1 64 0 -128 1 0 2 0 12 0 112 0 
> 0 0 0 0 7 -16 24 24 48 12 56 12 0 56 0 -32 0 -64 0 -128 0 0 0 0 1 -128 3 -64 1 -128 0 0 

> 注意：需要提交的是一个整数，不要填写任何多余内容。

```c

使用Word，将十行数据转换为两列一行的格式，以方便导入excel及处理。
使用DEC2BIN函数，进行进制转换
把字体拉小眯着眼睛
九的九次方等于多少？
答案是一个整数	387 420 489;
```

## 第几个幸运数

>到x星球旅行的游客都被发给一个整数，作为游客编号。
>x星的国王有个怪癖，他只喜欢数字 3, 5 和 7 。
>国王规定，游客的编号如果只含有因子：3 , 5, 7, 就可以获得一份奖品。

> 我们来看前10个幸运数字是：
> 3 5 7 9 15 21 25 27 35 45
> 因而第11个幸运数字是：49

> 小明领到了一个幸运数字 59084709587505。
> 他去领奖的时候，被要求准确地说出这是第几个幸运数字，否则领不到奖品。
> 请你帮小明计算一下，59084709587505是第几个幸运数字。

```c++
#include <iostream>
#include <algorithm>
#include <cmath>
using namespace std;
typedef long long ll;
ll n,c;
int main() {
    cin>>n;
    for(ll i = 1;i <= n;i *= 3) {
        for(ll j = 1;j * i <= n;j *= 5) {
            for(ll k = 1;k * j * i <= n;k *= 7) {
                c ++;
            }
        }
    }
    cout<<c - 1;
}
```

## 次数差

>x星球有26只球队，分别用a~z的26个字母代表。他们总是不停地比赛。
>在某一赛段，哪个球队获胜了，就记录下代表它的字母，这样就形成一个长长的串。
>国王总是询问：获胜次数最多的和获胜次数最少的有多大差距？（当然，他不关心那些一次也没获胜的，认为他们在怠工罢了）
>
>输入，一个串，表示球队获胜情况（保证串的长度<1000）
>
>要求输出一个数字，表示出现次数最多的字母比出现次数最少的字母多了多少次。

> 比如：
> 输入：
> abaabcaa

> 则程序应该输出：
> 4

> 解释：a出现5次，最多；c出现1次，最少。5-1=4

> 再比如：
> 输入：
> bbccccddaaaacccc

> 程序应该输出：
> 6

```c
#include <stdio.h>
#include <string.h>
char a2z[27]={"abcdefghijklmnopqrstuvwxyz"};
int ans[26];
char in[1005];

int max=0,min=999999; 


int main(int argc, char *argv[])
{
	gets(in);
	
	for(int i=0;i<strlen(in);i++){//串遍历 
		
		for(int j=0;j<26;j++){//字母遍历 
			if(in[i]==a2z[j]){
				ans[j]++;									
			}	
		}
		
	}
	
	for(int i=0;i<26;i++){
		if(ans[i]>max&&ans[i])max=ans[i]; 
		if(ans[i]<min&&ans[i])min=ans[i]; 	
	}
	
	printf("%d",max-min);
	return 0;
}
```



## 