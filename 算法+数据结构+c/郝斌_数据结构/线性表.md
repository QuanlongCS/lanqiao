# 绪论

## 前置条件

> 在学习数据结构之前你应该掌握一门编程语言,以c为例。你应该掌握以下知识

- 指针
- 结构体
- typedef
- 动态内存的分配与释放



## 1 指针

### 通过函数传参

```c
	int i=10;
	printf("%d\n",i);
	f(&i);//2函数的调用部分，声明是已经声明函数的形参是指针变量，使用函数再传参时应该传地址
	printf("%d\n",i);
	void f(int* x){
		*x=100;
	}
//定义函数原型时声明形参以及类型
	返回类型void f(int* x){//括号内形参是传进指针变量，实际的实参应该是一个地址
        *x=100;//解引用对其直接修改地址的值
    }

```







## 2 结构体

```c
struct Student{
    int id;
    int age;
    char name[100];
};
struct Student st;//直接使用结构体
struct Student* pst=&st;//使用指针指向结构体
通过结构体变量名
    st.id;
通过指向结构体指针
    pst->id;//直接指向结构体内的变量
传参问题？（普通结构传参数，结构体指针传参）	

1.
	st.id;
	st.age;
	st.name;
2.
	pst->id;
	pst->age;
	pst->name;
	
	f(&st);
void f(struct Student* pst){//pointe struct
    pst->id;
    (*st).id;
    
}

```

对于结构体指针的引用使用->

对于结构体的引用使用点.

### 结构传参数

```c
struct Student{
	int id;
	int age;
}; //定义一个结构

void f(struct Student *pst){//函数形参，规定实参为结构地址
	pst->id=111;//通过指针赋值 用这个符号
	pst->age=20;
}
main(){
    struct Student st;//声明一个结构
    f(&st);//调用函数并传参，st的地址
    printf("%d %d",st.age,st.id);//函数已经改变了st结构的值
}
```



## 3 动态内存的分配和释放

int* p=(int*)malloc(sizeof(int)*len)

free(p);

## 4 typedef

### 作用

```c++
为类型取一个名字
typedef int lql;
main(){
    
	lql i=10;
	cout<<i;//10
}
```

### 应用

```
typedef struct Student{
	int id;
	
}STU ;//定义个结构叫student


	STU st;
	STU* pst=&st;
	
	
```



# 顺序存储

```
int arr[len];
int* pArr=(int*)malloc(sizeof(int)*len);
```

### 抽象数据类型定义

```
ADT 线性表 (List)
	存储空间起始位置
	最大长度
	当前长度
	
Data 
	线性表数据集合为{a0,a1,a2,a3...},每个元素为DateType，
	除第一个元素a0外每一个元素都有前驱元素
	除最后一个元素an-1外每一个元素都有后驱元素
	
operation
	IninList(*L);
	ListEmpty(L);
	ClearList(*L);
	GetElem(L,i,*val);
	LocatrElem(L,val);
	Insert(*L,i,x);
	Delete(*L,i,*val);
	Length(L);
```



## 线性的优缺点

### 优点

无须为表示表中元素之间的逻辑关系而增加额外的存储空间

可以快速的存取任意位置元素

### 缺点

插入和删除需要移动大量的元素

当线性表长度变化较大使难以确定存储空间的容量

造成存储空间的浪费



# 链式存储

>逻辑结构上一个挨一个的数据，在实际存储时，并没有像[顺序表](http://data.biancheng.net/view/4.html)那样也相互紧挨着。恰恰相反，数据随机分布在内存中的各个位置，这种存储结构称为[线性表](http://data.biancheng.net/view/157.html)的链式存储。
>
> 由于分散存储，为了能够体现出数据元素之间的逻辑关系，每个数据元素在存储的同时，要配备一个指针，用于指向它的直接后继元素，即每一个数据元素都指向下一个数据元素（最后一个指向NULL(空)）。
>
>每一个数据元素都和它下一个数据元素用指针链接在一起时，就形成了一个链，这个链子的头就位于第一个数据元素，这样的存储方式就是链式存储。

## 结点

1. 本身的信息，称为“数据域”；
2. 指向直接后继的指针，称为“指针域”。

这两部分信息组成数据元素的存储结构，称之为“结点”。n个结点通过指针域相互链接，组成一个链表。

```
struct Node{
	int data;//数据域 
	struct Node* Next;//指针域 
	
}; 
```



## 头结点、头指针和首元结点



### 1头结点 head：

首节点之前的位置，并不存放数据，只是方便对链表操作 

> 若头结点的指针域为空（NULL），表明链表是空表。头结点对于链表来说，不是必须的，在处理某些问题时，给链表添加头结点会使问题变得简单。

永远指向链表中第一个结点的位置（如果链表有头结点，头指针指向头结点；否则，头指针指向首元结点）



### 2首结点：

（第一个有效节点）链表中第一个元素所在的结点，它是头结点后边的第一个结点。

### 3尾结点

​	存放最后一个有效数据 



### 4头指针：

永远指向链表中第一个结点的位置（**如果链表有头结点，头指针指向头结点**；否则，头指针指向第一个有效结点）。

> 头结点和头指针的区别：
>
> 头指针是一个指针，头指针指向链表的头结点或者首元结点；头结点是一个实际存在的结点，它包含有数据域和指针域。两者在程序中的直接体现就是：头指针只声明而没有分配存储空间，头结点进行了声明并分配了一个结点的实际物理内存

单链表中可以没有头结点，但是不能没有头指针

**结点**

<img src="D:\学习资料\大一暑假\郝彬-数据结构\img\LinkList_summary.png" style="zoom:75%;" />

>**头指针**->头结点			->首结点->...->尾结点
>
>
>
>头指针是必须的



## 插入节点

```
r=p->pNext; 
p->pNext=q; 
q->pNext=r;

q->pNext = p->pNext;
p->pNext=q;
```



## 删除结点

r=p->pNext;

p->pNext=p->pNext->pNext;

free(r);





## 链表的创建 和 遍历

> 万事开头难，初始化链表首先要做的就是创建**链表的头结点**或者首元结点。
>
> 创建的同时，要保证有一个指针永远**指向的是链表的表头**，这样做不至于丢失链表。
>
> 也就是头指针



### 无头结点的创建方法

```
创建头指针,初始值=null
创建首节点(并初始化数据域 指针域=null)
头指针指向首节点
循环开始
	创建新结点(并初始化数据域 指针域=null)
	建立首结点与新结点的逻辑关系(首结点的指针域指向新结点,新结点变成下个首结点)
返回头指针	
```

### 有头结点的创建方法

> 有头的区别在于头不能直接使用头需要先向下一级寻找指针指向，在使用指针域

```
创建头节点
创建头指针,指向头节点
循环(表长)
	开辟新结点内存，输入结点数据域，指针域为*空*
	建立新结点与头指针的逻辑关系
返回头结点
```



















<hr>



# 小结

## 线性结构

## 非线性结构

```
每个结点离散分配
通过指针相连
每个节点有且只有一个前驱节点，一个后驱节点
首节点没有前驱，尾结点没有后驱
```

### 名词解释

```c
//首结点
		第一个有效结点
//尾结点
    	最后一个有效节点
//头节点head
        在首节点之前的结点（方便对链表操作）    
//*头指针*
        指向头节点的指针变量
//尾指针
		指向尾结点的指针变量

```

# 双向链表

## 1简介与概念

在单链表的基础之上产生了双向链表的概念即每个结点增加一个前驱指针，指向前一个结点。相互连接构成链表

A[*pre + data + *next]
它的头节点的pre指针为空,尾结点的next为空，其余结点相互连接

```c
typedef struct doubleL{
	struct *pre;
	int data;
	struct *next;
}doubleL, *LL; 
```

## 2创建

对于创建双向链表，我们需要先创建头结点再逐步的进行添加，请注意，双向链表的头结点是有数据元素的，也就是头结点的data域中是存有数据的，这与一般的单链表是不同的。

## 3插入

<img src="D:\学习资料\大一暑假\数据结构\img\doubleLinsert.png" style="zoom:80%;" />

# 循环链表

## 定义

与普通链表唯一不同的是，非循环链表的尾结点指向空（NULL），而循环链表的尾指针指向的是链表的开头。通过将单链表的尾结点指向头结点的链表称之为循环单链表（Circular linkedlist）

<img src="D:\学习资料\大一暑假\数据结构\img\循环链表.png" style="zoom:80%;" />

## 创建

我们可以通过逐步的插入操作，创建一个新的节点，将原有链表尾结点的next指针修改指向到新的结点，新的结点的next指针再重新指向头部结点，然后逐步进行这样的插入操作，最终完成整个单项循环链表的创建。







